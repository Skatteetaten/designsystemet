import {
  Meta,
  Primary,
  Controls,
  ArgTypes,
} from '@storybook/addon-docs/blocks';
import { PlayroomCanvas as Canvas } from '../../../playroom/utils';
import * as ComboboxStories from './Combobox.stories';
import { VersionBadge } from '../../utils/VersionBadge';
import { DocIntro } from '../../utils/DocIntro';
import { DocHeaderWrapper } from '../../utils/DocHeaderWrapper';

<Meta of={ComboboxStories} />

<DocHeaderWrapper componentName="Combobox">

# Combobox

<VersionBadge packageName={'forms'} />

<DocIntro url="https://www.skatteetaten.no/stilogtone/designsystemet/komponenter/Combobox/" />

</DocHeaderWrapper>

Combobox er en interaktiv komponent som kombinerer funksjonaliteten til en dropdown og et tekstfelt. Brukere kan enten velge fra en liste med forhåndsdefinerte alternativer eller skrive inn egen tekst for å filtrere og søke gjennom alternativene.

Komponenten støtter både enkelt- og flervalg, og kan brukes i både kontrollert og ukontrollert modus.

<Primary />

```tsx
import { Combobox } from '@skatteetaten/ds-forms';
```

## Props

<Controls />

## Event Handlers

Combobox tilbyr flere event handlers for å håndtere brukerinteraksjon:

### onSelectionChange

Kalles når brukeren endrer valget sitt. Parameteren varierer basert på modus:

```tsx
// Enkeltvalg - mottar ComboboxOption | null
<Combobox
  onSelectionChange={(option) => {
    console.log('Valgt:', option?.label); // "Valgt: Norge" eller null
  }}
/>

// Flervalg - mottar ComboboxOption[]
<Combobox
  multiple
  onSelectionChange={(options) => {
    console.log('Antall valgte:', options.length);
    console.log('Valgte verdier:', options.map(o => o.value));
  }}
/>
```

### onInputChange

Kalles når input-teksten endres (kun i ukontrollert modus). Nyttig for asynkron søk:

```tsx
<Combobox
  onInputChange={(inputValue) => {
    console.log('Søketekst:', inputValue);
    // Utfør asynkron søk basert på inputValue
    searchAsync(inputValue).then(setFilteredOptions);
  }}
/>
```

#### Asynkron søk i kontrollert modus

I kontrollert modus har du ikke tilgang til `onInputChange`, men kan fortsatt implementere asynkron søk ved å bruke TanStack Query (anbefalt):

```tsx
import { useQuery } from '@tanstack/react-query';
import { useState } from 'react';

const SearchCombobox = () => {
  const [searchValue, setSearchValue] = useState('');

  // TanStack Query håndterer caching, deduplication og error states
  const { data: options = [], isLoading } = useQuery({
    queryKey: ['combobox-search', searchValue],
    queryFn: () => searchAPI(searchValue),
    enabled: !!searchValue,
    staleTime: 5 * 60 * 1000, // Cache i 5 minutter
  });

  return (
    <Combobox
      label="Søk i database"
      value={searchValue}
      options={options}
      isLoading={isLoading}
      onSelectionChange={(option) => {
        if (option) {
          setSearchValue(option.value);
          handleSelection(option);
        }
      }}
    />
  );
};
```

### onHelpToggle

Kalles når hjelpeteksten åpnes eller lukkes:

```tsx
<Combobox
  helpText="Dette er hjelpetekst"
  onHelpToggle={(isOpen) => {
    console.log('Hjelpetekst er', isOpen ? 'åpen' : 'lukket');
    // Spor bruk av hjelpefunksjonalitet
    analytics.track('help_toggled', { component: 'combobox', isOpen });
  }}
/>
```

## Bruksmønstre

### Enkeltvalg (Single Select)

```tsx
// Kontrollert modus - du styrer verdien selv
<Combobox
  label="Velg land"
  options={countryOptions}
  value={selectedCountry}
  onSelectionChange={(option) => {
    // option er ComboboxOption | null
    setSelectedCountry(option?.value || '');
    console.log('Nytt valg:', option?.label);
  }}
/>

// Ukontrollert modus - komponenten styrer sin egen tilstand
<Combobox
  label="Velg land"
  options={countryOptions}
  onSelectionChange={(option) => {
    // Kun for overvåking/logging av valg
    console.log('Bruker valgte:', option?.label);
    analytics.track('country_selected', { country: option?.value });
  }}
/>
```

### Flervalg (Multi Select)

```tsx
<Combobox
  multiple
  label="Velg kommuner"
  options={municipalityOptions}
  value={selectedMunicipalities}
  onSelectionChange={(options) => {
    // options er ComboboxOption[] array
    const values = options.map((o) => o.value);
    setSelectedMunicipalities(values);

    // Vis bruker feedback
    console.log(`${options.length} kommuner valgt`);
    if (options.length >= 5) {
      showMessage('Maksimalt antall kommuner valgt');
    }
  }}
  maxSelected={5}
/>
```

## Grupperte alternativer

Combobox støtter gruppering av alternativer ved å legge til et `group`-felt på options. Dette er nyttig for å organisere lange lister og gjøre det lettere for brukeren å finne riktig alternativ.

```tsx
const groupedOptions = [
  // Alternativer med samme group-verdi grupperes sammen
  { label: 'Trondheim', value: 'trondheim', group: 'Trøndelag' },
  { label: 'Steinkjer', value: 'steinkjer', group: 'Trøndelag' },
  { label: 'Bergen', value: 'bergen', group: 'Vestland' },
  { label: 'Voss', value: 'voss', group: 'Vestland' },
  // Alternativer uten group vises som vanlige options
  { label: 'Annen kommune', value: 'annen' },
];

<Combobox label="Velg kommune" options={groupedOptions} />;
```

### Egenskaper ved gruppering

- **Visuell gruppering**: Alternativer med samme `group`-verdi vises sammen under en felles overskrift
- **Rekkefølge bevares**: Grupper opprettes basert på rekkefølgen i options-arrayen
- **Filtrering**: Når brukeren filtrerer, skjules tomme grupper automatisk
- **Blanding**: Du kan kombinere grupperte og ugrupperte alternativer i samme liste
- **Tilgjengelighet**: Grupper bruker `role="group"` med `aria-labelledby` for skjermleserstøtte
- **Flervalg**: Gruppering fungerer også med `multiple`-modus

### Eksempel: Grupperte alternativer

<Canvas of={ComboboxStories.GroupedOptions} />

### Eksempel: Flervalg med grupperte alternativer

<Canvas of={ComboboxStories.GroupedOptionsMultiple} />

### Eksempel: Blandet grupperte og ugrupperte

<Canvas of={ComboboxStories.MixedGroupedOptions} />

## Examples

### Enkeltvalg

<Canvas of={ComboboxStories.Single} />

### Flervalg

<Canvas of={ComboboxStories.Multiple} />

### Med skjemavalidering

<Canvas of={ComboboxStories.WithValidation} />

### Begrenset antall valg

<Canvas of={ComboboxStories.MaxSelected} />

### Skjemaeksempel

<Canvas of={ComboboxStories.MultipleWithFormExample} />

## React Hook Form integrasjon

Combobox kan enkelt integreres med react-hook-form ved å bruke `Controller` komponenten. Dette er nødvendig fordi Combobox bruker ikke-standard prop-navn (`onSelectionChange` i stedet for `onChange`).

### Hvorfor Controller er nødvendig

React Hook Form forventer standard HTML form-konvensjoner, men Combobox har :

- `onSelectionChange` (i stedet for `onChange`)
- Sender `ComboboxOption` objekter (i stedet for primitive verdier)

Det har vi gjort for å unngå navneforvirring gjennom å gjøre API-et mer beskrivende.

`Controller` gjør det mulig å mappe mellom react-hook-form sitt API og Combobox sitt API.

### Enkeltvalg med react-hook-form

```tsx
import { Controller, useForm } from 'react-hook-form';
import { Combobox } from '@skatteetaten/ds-forms';

const MyForm = () => {
  const { control, handleSubmit } = useForm({
    defaultValues: {
      vegetable: '',
    },
  });

  const onSubmit = (data) => {
    console.log('Valgt grønnsak:', data.vegetable);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <Controller
        name="vegetable"
        control={control}
        rules={{ required: 'Du må velge en grønnsak' }}
        render={({
          field: { onChange, value, name },
          fieldState: { error },
        }) => (
          <Combobox
            name={name}
            label="Velg grønnsak"
            value={value}
            options={vegetableOptions}
            errorMessage={error?.message}
            onSelectionChange={(option) => onChange(option?.value || '')}
          />
        )}
      />
    </form>
  );
};
```

### Flervalg med react-hook-form

```tsx
import { Controller, useForm } from 'react-hook-form';
import { Combobox } from '@skatteetaten/ds-forms';

const MyForm = () => {
  const { control, handleSubmit } = useForm({
    defaultValues: {
      fruits: [],
    },
  });

  const onSubmit = (data) => {
    console.log('Valgte frukter:', data.fruits);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <Controller
        name="fruits"
        control={control}
        rules={{
          validate: (value) => value.length > 0 || 'Du må velge minst én frukt',
        }}
        render={({
          field: { onChange, value, name },
          fieldState: { error },
        }) => (
          <Combobox
            name={name}
            label="Velg frukter"
            value={value}
            options={fruitOptions}
            errorMessage={error?.message}
            multiple
            onSelectionChange={(options) =>
              onChange(options.map((opt) => opt.value))
            }
          />
        )}
      />
    </form>
  );
};
```

### API-søk med debouncing i react-hook-form

For API-søk kan du kombinere `onInputChange` med `minSearchLength` for å unngå for mange kall. Her er et eksempel med debouncing:

```tsx
import { Controller, useForm } from 'react-hook-form';
import { Combobox } from '@skatteetaten/ds-forms';
import { useState } from 'react';

const MyForm = () => {
  const { control } = useForm({
    defaultValues: { user: '' },
  });

  const [searchResults, setSearchResults] = useState([]);

  // Mock API-funksjon
  const searchUsers = async (searchTerm) => {
    const response = await fetch(`/api/users?search=${searchTerm}`);
    return response.json();
  };

  return (
    <Controller
      name="user"
      control={control}
      render={({ field: { onChange, value, name }, fieldState: { error } }) => {
        let debounceTimer;

        return (
          <Combobox
            name={name}
            label="Søk etter bruker"
            value={value}
            options={[...userOptions, ...searchResults]}
            errorMessage={error?.message}
            minSearchLength={2}
            onSelectionChange={(option) => onChange(option?.value || '')}
            onInputChange={(searchTerm) => {
              clearTimeout(debounceTimer);
              debounceTimer = setTimeout(() => {
                if (searchTerm.length >= 2) {
                  searchUsers(searchTerm).then(setSearchResults);
                }
              }, 300);
            }}
          />
        );
      }}
    />
  );
};
```
