{"version":3,"file":"FileUploader.test.stories-o8vnQ3Rl.js","sources":["../../../../node_modules/@testing-library/user-event/dist/esm/utils/click/isClickableInput.js","../../../../node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/Clipboard.js","../../../../node_modules/@testing-library/user-event/dist/esm/utils/edit/isEditable.js","../../../../node_modules/@testing-library/user-event/dist/esm/utils/edit/maxLength.js","../../../../node_modules/@testing-library/user-event/dist/esm/utils/keyDef/readNextDescriptor.js","../../../../node_modules/@testing-library/user-event/dist/esm/utils/misc/level.js","../../../../node_modules/@testing-library/user-event/dist/esm/options.js","../../../../node_modules/@testing-library/user-event/dist/esm/system/keyboard.js","../../../../node_modules/@testing-library/user-event/dist/esm/keyboard/keyMap.js","../../../../node_modules/@testing-library/user-event/dist/esm/pointer/keyMap.js","../../../../node_modules/@testing-library/user-event/dist/esm/setup/setup.js"],"sourcesContent":["import { isElementType } from '../misc/isElementType.js';\n\nvar clickableInputTypes;\n(function(clickableInputTypes) {\n    clickableInputTypes[\"button\"] = \"button\";\n    clickableInputTypes[\"color\"] = \"color\";\n    clickableInputTypes[\"file\"] = \"file\";\n    clickableInputTypes[\"image\"] = \"image\";\n    clickableInputTypes[\"reset\"] = \"reset\";\n    clickableInputTypes[\"submit\"] = \"submit\";\n    clickableInputTypes[\"checkbox\"] = \"checkbox\";\n    clickableInputTypes[\"radio\"] = \"radio\";\n})(clickableInputTypes || (clickableInputTypes = {}));\nfunction isClickableInput(element) {\n    return isElementType(element, 'button') || isElementType(element, 'input') && element.type in clickableInputTypes;\n}\n\nexport { isClickableInput };\n","import { getWindow } from '../misc/getWindow.js';\nimport { readBlobText } from './Blob.js';\nimport { createDataTransfer, getBlobFromDataTransferItem } from './DataTransfer.js';\n\n// Clipboard is not available in jsdom\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n// MDN lists string|Blob|Promise<Blob|string> as possible types in ClipboardItemData\n// lib.dom.d.ts lists only Promise<Blob|string>\n// https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#syntax\nfunction createClipboardItem(window, ...blobs) {\n    const dataMap = Object.fromEntries(blobs.map((b)=>[\n            typeof b === 'string' ? 'text/plain' : b.type,\n            Promise.resolve(b)\n        ]));\n    // use real ClipboardItem if available\n    /* istanbul ignore if */ if (typeof window.ClipboardItem !== 'undefined') {\n        return new window.ClipboardItem(dataMap);\n    }\n    return new class ClipboardItem {\n        get types() {\n            return Array.from(Object.keys(this.data));\n        }\n        async getType(type) {\n            const value = await this.data[type];\n            if (!value) {\n                throw new Error(`${type} is not one of the available MIME types on this item.`);\n            }\n            return value instanceof window.Blob ? value : new window.Blob([\n                value\n            ], {\n                type\n            });\n        }\n        constructor(d){\n            _define_property(this, \"data\", void 0);\n            this.data = d;\n        }\n    }(dataMap);\n}\nconst ClipboardStubControl = Symbol('Manage ClipboardSub');\nfunction createClipboardStub(window, control) {\n    return Object.assign(new class Clipboard extends window.EventTarget {\n        async read() {\n            return Array.from(this.items);\n        }\n        async readText() {\n            let text = '';\n            for (const item of this.items){\n                const type = item.types.includes('text/plain') ? 'text/plain' : item.types.find((t)=>t.startsWith('text/'));\n                if (type) {\n                    text += await item.getType(type).then((b)=>readBlobText(b, window.FileReader));\n                }\n            }\n            return text;\n        }\n        async write(data) {\n            this.items = data;\n        }\n        async writeText(text) {\n            this.items = [\n                createClipboardItem(window, text)\n            ];\n        }\n        constructor(...args){\n            super(...args);\n            _define_property(this, \"items\", []);\n        }\n    }(), {\n        [ClipboardStubControl]: control\n    });\n}\nfunction isClipboardStub(clipboard) {\n    return !!(clipboard === null || clipboard === void 0 ? void 0 : clipboard[ClipboardStubControl]);\n}\nfunction attachClipboardStubToView(window) {\n    if (isClipboardStub(window.navigator.clipboard)) {\n        return window.navigator.clipboard[ClipboardStubControl];\n    }\n    const realClipboard = Object.getOwnPropertyDescriptor(window.navigator, 'clipboard');\n    let stub;\n    const control = {\n        resetClipboardStub: ()=>{\n            stub = createClipboardStub(window, control);\n        },\n        detachClipboardStub: ()=>{\n            /* istanbul ignore if */ if (realClipboard) {\n                Object.defineProperty(window.navigator, 'clipboard', realClipboard);\n            } else {\n                Object.defineProperty(window.navigator, 'clipboard', {\n                    value: undefined,\n                    configurable: true\n                });\n            }\n        }\n    };\n    stub = createClipboardStub(window, control);\n    Object.defineProperty(window.navigator, 'clipboard', {\n        get: ()=>stub,\n        configurable: true\n    });\n    return stub[ClipboardStubControl];\n}\nfunction resetClipboardStubOnView(window) {\n    if (isClipboardStub(window.navigator.clipboard)) {\n        window.navigator.clipboard[ClipboardStubControl].resetClipboardStub();\n    }\n}\nfunction detachClipboardStubFromView(window) {\n    if (isClipboardStub(window.navigator.clipboard)) {\n        window.navigator.clipboard[ClipboardStubControl].detachClipboardStub();\n    }\n}\nasync function readDataTransferFromClipboard(document) {\n    const window = document.defaultView;\n    const clipboard = window === null || window === void 0 ? void 0 : window.navigator.clipboard;\n    const items = clipboard && await clipboard.read();\n    if (!items) {\n        throw new Error('The Clipboard API is unavailable.');\n    }\n    const dt = createDataTransfer(window);\n    for (const item of items){\n        for (const type of item.types){\n            dt.setData(type, await item.getType(type).then((b)=>readBlobText(b, window.FileReader)));\n        }\n    }\n    return dt;\n}\nasync function writeDataTransferToClipboard(document, clipboardData) {\n    const window = getWindow(document);\n    const clipboard = window.navigator.clipboard;\n    const items = [];\n    for(let i = 0; i < clipboardData.items.length; i++){\n        const dtItem = clipboardData.items[i];\n        const blob = getBlobFromDataTransferItem(window, dtItem);\n        items.push(createClipboardItem(window, blob));\n    }\n    const written = clipboard && await clipboard.write(items).then(()=>true, // Can happen with other implementations that e.g. require permissions\n    /* istanbul ignore next */ ()=>false);\n    if (!written) {\n        throw new Error('The Clipboard API is unavailable.');\n    }\n}\nconst g = globalThis;\n/* istanbul ignore else */ if (typeof g.afterEach === 'function') {\n    g.afterEach(()=>resetClipboardStubOnView(globalThis.window));\n}\n/* istanbul ignore else */ if (typeof g.afterAll === 'function') {\n    g.afterAll(()=>detachClipboardStubFromView(globalThis.window));\n}\n\nexport { attachClipboardStubToView, createClipboardItem, detachClipboardStubFromView, readDataTransferFromClipboard, resetClipboardStubOnView, writeDataTransferToClipboard };\n","import { isElementType } from '../misc/isElementType.js';\nimport { isContentEditable } from './isContentEditable.js';\n\nfunction isEditable(element) {\n    return isEditableInputOrTextArea(element) && !element.readOnly || isContentEditable(element);\n}\nvar editableInputTypes;\n(function(editableInputTypes) {\n    editableInputTypes[\"text\"] = \"text\";\n    editableInputTypes[\"date\"] = \"date\";\n    editableInputTypes[\"datetime-local\"] = \"datetime-local\";\n    editableInputTypes[\"email\"] = \"email\";\n    editableInputTypes[\"month\"] = \"month\";\n    editableInputTypes[\"number\"] = \"number\";\n    editableInputTypes[\"password\"] = \"password\";\n    editableInputTypes[\"search\"] = \"search\";\n    editableInputTypes[\"tel\"] = \"tel\";\n    editableInputTypes[\"time\"] = \"time\";\n    editableInputTypes[\"url\"] = \"url\";\n    editableInputTypes[\"week\"] = \"week\";\n})(editableInputTypes || (editableInputTypes = {}));\nfunction isEditableInputOrTextArea(element) {\n    return isElementType(element, 'textarea') || isElementType(element, 'input') && element.type in editableInputTypes;\n}\n\nexport { isEditable, isEditableInputOrTextArea };\n","import { isElementType } from '../misc/isElementType.js';\n\nvar maxLengthSupportedTypes;\n(function(maxLengthSupportedTypes) {\n    maxLengthSupportedTypes[\"email\"] = \"email\";\n    maxLengthSupportedTypes[\"password\"] = \"password\";\n    maxLengthSupportedTypes[\"search\"] = \"search\";\n    maxLengthSupportedTypes[\"telephone\"] = \"telephone\";\n    maxLengthSupportedTypes[\"text\"] = \"text\";\n    maxLengthSupportedTypes[\"url\"] = \"url\";\n})(maxLengthSupportedTypes || (maxLengthSupportedTypes = {}));\n// can't use .maxLength property because of a jsdom bug:\n// https://github.com/jsdom/jsdom/issues/2927\nfunction getMaxLength(element) {\n    var _element_getAttribute;\n    const attr = (_element_getAttribute = element.getAttribute('maxlength')) !== null && _element_getAttribute !== void 0 ? _element_getAttribute : '';\n    return /^\\d+$/.test(attr) && Number(attr) >= 0 ? Number(attr) : undefined;\n}\nfunction supportsMaxLength(element) {\n    return isElementType(element, 'textarea') || isElementType(element, 'input') && element.type in maxLengthSupportedTypes;\n}\n\nexport { getMaxLength, supportsMaxLength };\n","var bracketDict;\n(function(bracketDict) {\n    bracketDict[\"{\"] = \"}\";\n    bracketDict[\"[\"] = \"]\";\n})(bracketDict || (bracketDict = {}));\n/**\n * Read the next key definition from user input\n *\n * Describe key per `{descriptor}` or `[descriptor]`.\n * Everything else will be interpreted as a single character as descriptor - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * A previously pressed key can be released per `{/descriptor}`.\n * Keeping the key pressed can be written as `{descriptor>}`.\n * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.\n * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.\n */ function readNextDescriptor(text, context) {\n    let pos = 0;\n    const startBracket = text[pos] in bracketDict ? text[pos] : '';\n    pos += startBracket.length;\n    const isEscapedChar = new RegExp(`^\\\\${startBracket}{2}`).test(text);\n    const type = isEscapedChar ? '' : startBracket;\n    return {\n        type,\n        ...type === '' ? readPrintableChar(text, pos, context) : readTag(text, pos, type, context)\n    };\n}\nfunction readPrintableChar(text, pos, context) {\n    const descriptor = text[pos];\n    assertDescriptor(descriptor, text, pos, context);\n    pos += descriptor.length;\n    return {\n        consumedLength: pos,\n        descriptor,\n        releasePrevious: false,\n        releaseSelf: true,\n        repeat: 1\n    };\n}\nfunction readTag(text, pos, startBracket, context) {\n    var _text_slice_match, _text_slice_match1;\n    const releasePreviousModifier = text[pos] === '/' ? '/' : '';\n    pos += releasePreviousModifier.length;\n    const escapedDescriptor = startBracket === '{' && text[pos] === '\\\\';\n    pos += Number(escapedDescriptor);\n    const descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === '{' ? /^\\w+|^[^}>/]/ : /^\\w+/)) === null || _text_slice_match === void 0 ? void 0 : _text_slice_match[0];\n    assertDescriptor(descriptor, text, pos, context);\n    pos += descriptor.length;\n    var _text_slice_match_;\n    const repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\\d+/)) === null || _text_slice_match1 === void 0 ? void 0 : _text_slice_match1[0]) !== null && _text_slice_match_ !== void 0 ? _text_slice_match_ : '';\n    pos += repeatModifier.length;\n    const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';\n    pos += releaseSelfModifier.length;\n    const expectedEndBracket = bracketDict[startBracket];\n    const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';\n    if (!endBracket) {\n        throw new Error(getErrorMessage([\n            !repeatModifier && 'repeat modifier',\n            !releaseSelfModifier && 'release modifier',\n            `\"${expectedEndBracket}\"`\n        ].filter(Boolean).join(' or '), text[pos], text, context));\n    }\n    pos += endBracket.length;\n    return {\n        consumedLength: pos,\n        descriptor,\n        releasePrevious: !!releasePreviousModifier,\n        repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,\n        releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)\n    };\n}\nfunction assertDescriptor(descriptor, text, pos, context) {\n    if (!descriptor) {\n        throw new Error(getErrorMessage('key descriptor', text[pos], text, context));\n    }\n}\nfunction hasReleaseSelf(releaseSelfModifier, repeatModifier) {\n    if (releaseSelfModifier) {\n        return releaseSelfModifier === '/';\n    }\n    if (repeatModifier) {\n        return false;\n    }\n}\nfunction getErrorMessage(expected, found, text, context) {\n    return `Expected ${expected} but found \"${found !== null && found !== void 0 ? found : ''}\" in \"${text}\"\n    See ${context === 'pointer' ? `https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen` : `https://testing-library.com/docs/user-event/keyboard`}\n    for more information about how userEvent parses your input.`;\n}\n\nexport { readNextDescriptor };\n","var ApiLevel;\n(function(ApiLevel) {\n    ApiLevel[ApiLevel[\"Trigger\"] = 2] = \"Trigger\";\n    ApiLevel[ApiLevel[\"Call\"] = 1] = \"Call\";\n})(ApiLevel || (ApiLevel = {}));\nfunction setLevelRef(instance, level) {\n    instance.levelRefs[level] = {};\n}\nfunction getLevelRef(instance, level) {\n    return instance.levelRefs[level];\n}\n\nexport { ApiLevel, getLevelRef, setLevelRef };\n","var PointerEventsCheckLevel;\n(function(PointerEventsCheckLevel) {\n    /**\n   * Check pointer events on every user interaction that triggers a bunch of events.\n   * E.g. once for releasing a mouse button even though this triggers `pointerup`, `mouseup`, `click`, etc...\n   */ PointerEventsCheckLevel[PointerEventsCheckLevel[\"EachTrigger\"] = 4] = \"EachTrigger\";\n    /** Check each target once per call to pointer (related) API */ PointerEventsCheckLevel[PointerEventsCheckLevel[\"EachApiCall\"] = 2] = \"EachApiCall\";\n    /** Check each event target once */ PointerEventsCheckLevel[PointerEventsCheckLevel[\"EachTarget\"] = 1] = \"EachTarget\";\n    /** No pointer events check */ PointerEventsCheckLevel[PointerEventsCheckLevel[\"Never\"] = 0] = \"Never\";\n})(PointerEventsCheckLevel || (PointerEventsCheckLevel = {}));\n\nexport { PointerEventsCheckLevel };\n","import '../utils/click/isClickableInput.js';\nimport '../utils/dataTransfer/Clipboard.js';\nimport '../utils/edit/isEditable.js';\nimport '../utils/edit/maxLength.js';\nimport { getActiveElementOrBody } from '../utils/focus/getActiveElement.js';\nimport '../utils/keyDef/readNextDescriptor.js';\nimport '../utils/misc/level.js';\nimport '../options.js';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar DOM_KEY_LOCATION;\n(function(DOM_KEY_LOCATION) {\n    DOM_KEY_LOCATION[DOM_KEY_LOCATION[\"STANDARD\"] = 0] = \"STANDARD\";\n    DOM_KEY_LOCATION[DOM_KEY_LOCATION[\"LEFT\"] = 1] = \"LEFT\";\n    DOM_KEY_LOCATION[DOM_KEY_LOCATION[\"RIGHT\"] = 2] = \"RIGHT\";\n    DOM_KEY_LOCATION[DOM_KEY_LOCATION[\"NUMPAD\"] = 3] = \"NUMPAD\";\n})(DOM_KEY_LOCATION || (DOM_KEY_LOCATION = {}));\nconst modifierKeys = [\n    'Alt',\n    'AltGraph',\n    'Control',\n    'Fn',\n    'Meta',\n    'Shift',\n    'Symbol'\n];\nfunction isModifierKey(key) {\n    return modifierKeys.includes(key);\n}\nconst modifierLocks = [\n    'CapsLock',\n    'FnLock',\n    'NumLock',\n    'ScrollLock',\n    'SymbolLock'\n];\nfunction isModifierLock(key) {\n    return modifierLocks.includes(key);\n}\nclass KeyboardHost {\n    isKeyPressed(keyDef) {\n        return !!this.pressed[String(keyDef.code)];\n    }\n    getPressedKeys() {\n        return Object.values(this.pressed).map((p)=>p.keyDef);\n    }\n    /** Press a key */ async keydown(instance, keyDef) {\n        var // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        _this_pressed, _code, _this_pressed_code;\n        const key = String(keyDef.key);\n        const code = String(keyDef.code);\n        const target = getActiveElementOrBody(instance.config.document);\n        this.setKeydownTarget(target);\n        var _;\n        (_ = (_this_pressed = this.pressed)[_code = code]) !== null && _ !== void 0 ? _ : _this_pressed[_code] = {\n            keyDef,\n            unpreventedDefault: false\n        };\n        if (isModifierKey(key)) {\n            this.modifiers[key] = true;\n        }\n        const unprevented = instance.dispatchUIEvent(target, 'keydown', {\n            key,\n            code\n        });\n        if (isModifierLock(key) && !this.modifiers[key]) {\n            this.modifiers[key] = true;\n            this.modifierLockStart[key] = true;\n        }\n        (_this_pressed_code = this.pressed[code]).unpreventedDefault || (_this_pressed_code.unpreventedDefault = unprevented);\n        if (unprevented && this.hasKeyPress(key)) {\n            instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), 'keypress', {\n                key,\n                code,\n                charCode: keyDef.key === 'Enter' ? 13 : String(keyDef.key).charCodeAt(0)\n            });\n        }\n    }\n    /** Release a key */ async keyup(instance, keyDef) {\n        const key = String(keyDef.key);\n        const code = String(keyDef.code);\n        const unprevented = this.pressed[code].unpreventedDefault;\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete this.pressed[code];\n        if (isModifierKey(key) && !Object.values(this.pressed).find((p)=>p.keyDef.key === key)) {\n            this.modifiers[key] = false;\n        }\n        instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), 'keyup', {\n            key,\n            code\n        }, !unprevented);\n        if (isModifierLock(key) && this.modifiers[key]) {\n            if (this.modifierLockStart[key]) {\n                this.modifierLockStart[key] = false;\n            } else {\n                this.modifiers[key] = false;\n            }\n        }\n    }\n    setKeydownTarget(target) {\n        if (target !== this.lastKeydownTarget) {\n            this.carryChar = '';\n        }\n        this.lastKeydownTarget = target;\n    }\n    hasKeyPress(key) {\n        return (key.length === 1 || key === 'Enter') && !this.modifiers.Control && !this.modifiers.Alt;\n    }\n    constructor(system){\n        _define_property(this, \"system\", void 0);\n        _define_property(this, \"modifiers\", {\n            Alt: false,\n            AltGraph: false,\n            CapsLock: false,\n            Control: false,\n            Fn: false,\n            FnLock: false,\n            Meta: false,\n            NumLock: false,\n            ScrollLock: false,\n            Shift: false,\n            Symbol: false,\n            SymbolLock: false\n        });\n        _define_property(this, \"pressed\", {});\n        _define_property(this, \"carryChar\", '');\n        _define_property(this, \"lastKeydownTarget\", undefined);\n        _define_property(this, \"modifierLockStart\", {});\n        this.system = system;\n    }\n}\n\nexport { DOM_KEY_LOCATION, KeyboardHost };\n","import { DOM_KEY_LOCATION } from '../system/keyboard.js';\n\n/**\n * Mapping for a default US-104-QWERTY keyboard\n */ const defaultKeyMap = [\n    // alphanumeric keys\n    ...'0123456789'.split('').map((c)=>({\n            code: `Digit${c}`,\n            key: c\n        })),\n    ...')!@#$%^&*('.split('').map((c, i)=>({\n            code: `Digit${i}`,\n            key: c,\n            shiftKey: true\n        })),\n    ...'abcdefghijklmnopqrstuvwxyz'.split('').map((c)=>({\n            code: `Key${c.toUpperCase()}`,\n            key: c\n        })),\n    ...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').map((c)=>({\n            code: `Key${c}`,\n            key: c,\n            shiftKey: true\n        })),\n    // alphanumeric block - functional\n    {\n        code: 'Space',\n        key: ' '\n    },\n    {\n        code: 'AltLeft',\n        key: 'Alt',\n        location: DOM_KEY_LOCATION.LEFT\n    },\n    {\n        code: 'AltRight',\n        key: 'Alt',\n        location: DOM_KEY_LOCATION.RIGHT\n    },\n    {\n        code: 'ShiftLeft',\n        key: 'Shift',\n        location: DOM_KEY_LOCATION.LEFT\n    },\n    {\n        code: 'ShiftRight',\n        key: 'Shift',\n        location: DOM_KEY_LOCATION.RIGHT\n    },\n    {\n        code: 'ControlLeft',\n        key: 'Control',\n        location: DOM_KEY_LOCATION.LEFT\n    },\n    {\n        code: 'ControlRight',\n        key: 'Control',\n        location: DOM_KEY_LOCATION.RIGHT\n    },\n    {\n        code: 'MetaLeft',\n        key: 'Meta',\n        location: DOM_KEY_LOCATION.LEFT\n    },\n    {\n        code: 'MetaRight',\n        key: 'Meta',\n        location: DOM_KEY_LOCATION.RIGHT\n    },\n    {\n        code: 'OSLeft',\n        key: 'OS',\n        location: DOM_KEY_LOCATION.LEFT\n    },\n    {\n        code: 'OSRight',\n        key: 'OS',\n        location: DOM_KEY_LOCATION.RIGHT\n    },\n    {\n        code: 'Tab',\n        key: 'Tab'\n    },\n    {\n        code: 'CapsLock',\n        key: 'CapsLock'\n    },\n    {\n        code: 'Backspace',\n        key: 'Backspace'\n    },\n    {\n        code: 'Enter',\n        key: 'Enter'\n    },\n    // function\n    {\n        code: 'Escape',\n        key: 'Escape'\n    },\n    // arrows\n    {\n        code: 'ArrowUp',\n        key: 'ArrowUp'\n    },\n    {\n        code: 'ArrowDown',\n        key: 'ArrowDown'\n    },\n    {\n        code: 'ArrowLeft',\n        key: 'ArrowLeft'\n    },\n    {\n        code: 'ArrowRight',\n        key: 'ArrowRight'\n    },\n    // control pad\n    {\n        code: 'Home',\n        key: 'Home'\n    },\n    {\n        code: 'End',\n        key: 'End'\n    },\n    {\n        code: 'Delete',\n        key: 'Delete'\n    },\n    {\n        code: 'PageUp',\n        key: 'PageUp'\n    },\n    {\n        code: 'PageDown',\n        key: 'PageDown'\n    },\n    // Special keys that are not part of a default US-layout but included for specific behavior\n    {\n        code: 'Fn',\n        key: 'Fn'\n    },\n    {\n        code: 'Symbol',\n        key: 'Symbol'\n    },\n    {\n        code: 'AltRight',\n        key: 'AltGraph'\n    }\n];\n\nexport { defaultKeyMap };\n","const defaultKeyMap = [\n    {\n        name: 'MouseLeft',\n        pointerType: 'mouse',\n        button: 'primary'\n    },\n    {\n        name: 'MouseRight',\n        pointerType: 'mouse',\n        button: 'secondary'\n    },\n    {\n        name: 'MouseMiddle',\n        pointerType: 'mouse',\n        button: 'auxiliary'\n    },\n    {\n        name: 'TouchA',\n        pointerType: 'touch'\n    },\n    {\n        name: 'TouchB',\n        pointerType: 'touch'\n    },\n    {\n        name: 'TouchC',\n        pointerType: 'touch'\n    }\n];\n\nexport { defaultKeyMap };\n","import { prepareDocument } from '../document/prepareDocument.js';\nimport { dispatchEvent, dispatchUIEvent } from '../event/dispatchEvent.js';\nimport '../utils/click/isClickableInput.js';\nimport { attachClipboardStubToView } from '../utils/dataTransfer/Clipboard.js';\nimport '../utils/edit/isEditable.js';\nimport '../utils/edit/maxLength.js';\nimport '../utils/keyDef/readNextDescriptor.js';\nimport { getDocumentFromNode } from '../utils/misc/getDocumentFromNode.js';\nimport { setLevelRef, ApiLevel } from '../utils/misc/level.js';\nimport { wait } from '../utils/misc/wait.js';\nimport { PointerEventsCheckLevel } from '../options.js';\nimport '@testing-library/dom';\nimport { defaultKeyMap } from '../keyboard/keyMap.js';\nimport { defaultKeyMap as defaultKeyMap$1 } from '../pointer/keyMap.js';\nimport { System } from '../system/index.js';\nimport { userEventApi } from './api.js';\nimport { wrapAsync } from './wrapAsync.js';\n\n/**\n * Default options applied when API is called per `userEvent.anyApi()`\n */ const defaultOptionsDirect = {\n    applyAccept: true,\n    autoModify: true,\n    delay: 0,\n    document: globalThis.document,\n    keyboardMap: defaultKeyMap,\n    pointerMap: defaultKeyMap$1,\n    pointerEventsCheck: PointerEventsCheckLevel.EachApiCall,\n    skipAutoClose: false,\n    skipClick: false,\n    skipHover: false,\n    writeToClipboard: false,\n    advanceTimers: ()=>Promise.resolve()\n};\n/**\n * Default options applied when API is called per `userEvent().anyApi()`\n */ const defaultOptionsSetup = {\n    ...defaultOptionsDirect,\n    writeToClipboard: true\n};\nfunction createConfig(options = {}, defaults = defaultOptionsSetup, node) {\n    const document = getDocument(options, node, defaults);\n    return {\n        ...defaults,\n        ...options,\n        document\n    };\n}\n/**\n * Start a \"session\" with userEvent.\n * All APIs returned by this function share an input device state and a default configuration.\n */ function setupMain(options = {}) {\n    const config = createConfig(options);\n    prepareDocument(config.document);\n    var _config_document_defaultView;\n    const view = (_config_document_defaultView = config.document.defaultView) !== null && _config_document_defaultView !== void 0 ? _config_document_defaultView : /* istanbul ignore next */ globalThis.window;\n    attachClipboardStubToView(view);\n    return createInstance(config).api;\n}\n/**\n * Setup in direct call per `userEvent.anyApi()`\n */ function setupDirect({ keyboardState, pointerState, ...options } = {}, node) {\n    const config = createConfig(options, defaultOptionsDirect, node);\n    prepareDocument(config.document);\n    var _ref;\n    const system = (_ref = pointerState !== null && pointerState !== void 0 ? pointerState : keyboardState) !== null && _ref !== void 0 ? _ref : new System();\n    return {\n        api: createInstance(config, system).api,\n        system\n    };\n}\n/**\n * Create a set of callbacks with different default settings but the same state.\n */ function setupSub(options) {\n    return createInstance({\n        ...this.config,\n        ...options\n    }, this.system).api;\n}\nfunction wrapAndBindImpl(instance, impl) {\n    function method(...args) {\n        setLevelRef(instance, ApiLevel.Call);\n        return wrapAsync(()=>impl.apply(instance, args).then(async (ret)=>{\n                await wait(instance.config);\n                return ret;\n            }));\n    }\n    Object.defineProperty(method, 'name', {\n        get: ()=>impl.name\n    });\n    return method;\n}\nfunction createInstance(config, system = new System()) {\n    const instance = {};\n    Object.assign(instance, {\n        config,\n        dispatchEvent: dispatchEvent.bind(instance),\n        dispatchUIEvent: dispatchUIEvent.bind(instance),\n        system,\n        levelRefs: {},\n        ...userEventApi\n    });\n    return {\n        instance,\n        api: {\n            ...Object.fromEntries(Object.entries(userEventApi).map(([name, api])=>[\n                    name,\n                    wrapAndBindImpl(instance, api)\n                ])),\n            setup: setupSub.bind(instance)\n        }\n    };\n}\nfunction getDocument(options, node, defaults) {\n    var _options_document, _ref;\n    return (_ref = (_options_document = options.document) !== null && _options_document !== void 0 ? _options_document : node && getDocumentFromNode(node)) !== null && _ref !== void 0 ? _ref : defaults.document;\n}\n\nexport { createConfig, createInstance, setupDirect, setupMain, setupSub };\n"],"names":["clickableInputTypes","ClipboardStubControl","isClipboardStub","clipboard","resetClipboardStubOnView","window","detachClipboardStubFromView","g","editableInputTypes","maxLengthSupportedTypes","bracketDict","ApiLevel","PointerEventsCheckLevel","DOM_KEY_LOCATION","defaultKeyMap","c","i"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10]}